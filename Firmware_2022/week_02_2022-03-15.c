/*
* ===============================
	펌웨어 및 디바이스 드라이버
	2022-03-15 포인터와 배열 복습
* ===============================
*/


#include <stdio.h>


int main() {


#if 0
	char a[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };

	// a =100 기준 상대주소 {100}

	printf("a는 %p\n", a); // 0095F6EC {100}
	// a 는 첫번째 덩어리의 주소(4개짜리 한 덩어리)

	printf("a[0]는 %p\n", a[0]); // 0095F6EC {100}
	// a[0]는 첫번째 덩어리의 주소(1 하나짜리 덩어리)

	printf("a[1]는 %p\n", a[1]); //0095F6F0 {104}
	// a[1]는 두번째 덩어리의 주소 (5 하나짜리 덩어리)


	printf("a[0]+1는 %p\n", a[0]+1); //0095F6ED {101}
	// a[0]는 1이라는 값의 주소임 (1개짜리 덩어리) 
	// +1을 하면 char단위의 하나 다음인 '2'가 있는 곳의 주소를 가리킴

	printf("a+1는 %p\n", a + 1); // 008FFA08 {104}


	// a[1] = *(a+1) 과 완전히 같은 표현
	printf("a[1]는 %p\n", a[1]); // 0095F6F0 {104}
	printf("*(a+1)는 %p\n", *(a + 1)); //0095F6F0 {104}

	// 왜 a+1 도 104고, *(a+1)도 104인가?
	// => a+1는 4개짜리 덩어리를 기준으로 하나 다음주소라서 {5,6,7,8}이 들어있는 4개짜리 덩어리의 시작주소
	// => *(a+1) 4개짜리 덩어리에서 다음 한 덩어리로 간 다음 하나 안의 값이라 {5}하나 들어있는 덩어리의 주소임
	// 둘 다 {5}가 있는 위치인 104가 맞지만 그 덩어리의 크기가 다름


	// 값일까 주소일까?
	printf("*a[1]는 %d\n", *a[1]); // 5
	printf("*(a+1)는 %p\n", *(a + 1)); // '5'가 있는 곳에 있는 주소 {104}
	printf("*(a+1)+1는 %p\n", *(a + 1)+1); // '6'이 있는 곳의 주소 {105}
	printf("*((a+1)+1)는 %p\n", *((a + 1) + 1)); // '9'가 있는 곳의 주소 {108}
#endif

#if 0
	int a[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };

	int* p = a; // 대부분 컴파일러는 경고를 내거나 에러를 냄
	int* casted_p = (int*)a; // 처럼 캐스팅을 해줘야함!

	int(*q)[4] = a; //배열의 포인터
	// q는 int포인터인데, int 짜리 4개를 한 덩어리씩 건너뛰어라!

	// a와 q는 완전하게 동일함!! 
	// a를 쓸 수 있는 모든 곳에 q로 표현 가능함!

	printf("q+1는 %p\n", q+1); // {104}
	printf("*(q+1)는 %p\n", *(q + 1)); // {104}
	printf("**(q+1)는 %d\n", **(q + 1)); // 5


	// 이차원 배열이 더블포인터인가?

	int** r = a;

#endif	


	return 0;
}
